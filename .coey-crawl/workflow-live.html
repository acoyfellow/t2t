<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸ¤–</text></svg>">

		<meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="generator" content="coey.dev" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link
      rel="preconnect"
      href="https://fonts.gstatic.com"
      crossorigin="anonymous"
    />
    <link class="deferred-stylesheet" rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Google+Sans:300,400,500,600,700&family=Google+Sans+Mono:300,400,500,600,700&amp;display=swap&amp;lang=en" as="style">

		
		<link href="./_app/immutable/assets/0.-k1r2YJt.css" rel="stylesheet">
		<link href="./_app/immutable/assets/CodeBlock.mf1IAhYo.css" rel="stylesheet"><!--12qhfyh--><meta name="description" content="Developer thoughts and code"/><!----><!--ojxrft--><meta name="description" content="See your workflows breatheâ€”live stages, errors, durations under 1s."/> <meta name="keywords" content="workflow, monitoring, real-time, cloudflare, analytics engine"/> <link rel="canonical" href="https://coey.dev/workflow-live"/> <meta name="author" content="Jordan Coeyman"/> <!--[!--><!--]--> <meta property="og:title" content="Workflow Live: Real-time workflow monitoring on the edge"/> <meta property="og:description" content="See your workflows breatheâ€”live stages, errors, durations under 1s."/> <meta property="og:type" content="article"/> <meta property="og:url" content="https://coey.dev/workflow-live"/> <meta property="og:image" content="https://api.coey.dev/?title=Workflow%20Live%3A%20Real-time%20workflow%20monitoring%20on%20the%20edge&amp;description=See%20your%20workflows%20breathe%E2%80%94live%20stages%2C%20errors%2C%20durations%20under%201s."/> <meta property="og:site_name" content="coey.dev"/> <meta name="twitter:card" content="summary_large_image"/> <meta name="twitter:title" content="Workflow Live: Real-time workflow monitoring on the edge"/> <meta name="twitter:description" content="See your workflows breatheâ€”live stages, errors, durations under 1s."/> <meta name="twitter:image" content="https://api.coey.dev/?title=Workflow%20Live%3A%20Real-time%20workflow%20monitoring%20on%20the%20edge&amp;description=See%20your%20workflows%20breathe%E2%80%94live%20stages%2C%20errors%2C%20durations%20under%201s."/> <meta name="twitter:site" content="@acoyfellow"/> <!--[--><meta property="article:published_time" content="2025-09-22"/> <meta property="article:modified_time" content="2025-09-22"/> <!--[--><meta property="article:section" content="technical"/><!--]--> <!--[--><meta property="article:tag" content="cloudflare,workflow,monitoring"/><!--]--><!--]-->  <!----><script type="application/ld+json" nonce="%sveltekit.nonce%">{
  "@context": "https://schema.org",
  "@type": "Organization",
  "name": "Jordan Coeyman",
  "url": "https://coey.dev",
  "logo": {
    "@type": "ImageObject",
    "url": "https://coey.dev/jordan.jpg"
  },
  "sameAs": [
    "https://x.com/acoyfellow",
    "https://github.com/acoyfellow"
  ]
}</script><!----> <!--[!--><!--]--> <!--[--><!----><script type="application/ld+json" nonce="%sveltekit.nonce%">{
  "@context": "https://schema.org",
  "@type": "Article",
  "headline": "Workflow Live: Real-time workflow monitoring on the edge",
  "description": "See your workflows breatheâ€”live stages, errors, durations under 1s.",
  "image": "https://api.coey.dev/?title=Workflow%20Live%3A%20Real-time%20workflow%20monitoring%20on%20the%20edge&description=See%20your%20workflows%20breathe%E2%80%94live%20stages%2C%20errors%2C%20durations%20under%201s.",
  "wordCount": 0,
  "author": {
    "@type": "Organization",
    "name": "Jordan Coeyman"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Jordan Coeyman",
    "logo": {
      "@type": "ImageObject",
      "url": "https://coey.dev/jordan.jpg"
    }
  },
  "datePublished": "2025-09-22",
  "dateModified": "2025-09-22",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://coey.dev/workflow-live"
  }
}</script><!----><!--]--> <!--[!--><!--]--><!----><title>Workflow Live: Real-time workflow monitoring on the edge</title>
	</head>
	<body data-sveltekit-preload-data="hover">
		<div style="display: contents"><!--[--><!--[--><!----><header class="flex items-center justify-between p-4 gap-4 flex-wrap" id="nav"><a href="/" class="px-4 py-2 md:px-8 md:py-4 md:text-2xl font-black hover:bg-white hover:text-black border-4 border-black hover:border-white bg-white text-black">coey.dev</a> <nav><div class="flex gap-0"><a href="/" class="px-4 py-2 md:px-8 md:py-4 md:text-2xl font-black hover:bg-white hover:text-black border-4 border-black bg-white text-black">POSTS</a> <a href="/about" class="px-4 py-2 md:px-8 md:py-4 md:text-2xl font-black hover:bg-black hover:text-white border-4 border-black border-l-0 bg-white text-black">ABOUT</a></div></nav></header> <div class="fixed inset-0 pointer-events-none -z-10" style="opacity: 0.7; mix-blend-mode: multiply; will-change: transform;"></div><!----> <main class="pt-20 relative"><!----><!--[--><!--]--> <main class="bg-white text-black"><div class="max-w-4xl mx-auto px-6 py-12"><header class="border-b-2 border-black pb-8 mb-12"><h1 class="text-4xl font-bold uppercase tracking-wider mb-4">WORKFLOW LIVE</h1> <p class="text-xl font-mono">Real-time workflow monitoring on the edge</p> <div class="mt-4 font-mono"><span class="bg-black text-white px-2 py-1">MONITORING PATTERN</span> <span class="ml-4">2025.09.22</span></div></header> <section class="mb-12 border-l-2 border-black pl-6"><h2 class="text-2xl font-bold font-mono mb-4">THE WORKFLOW VISIBILITY PROBLEM</h2> <p class="text-lg leading-relaxed mb-4"><strong>Problem:</strong> Workflows run in the background with no visibility.
        You only know they failed when users complain.</p> <p class="leading-relaxed mb-4"><strong>Solution:</strong> Workflow Live provides real-time monitoring with
        WebSocket updates, Durable Object rooms per workflow, and Analytics Engine
        for historical data.</p> <div class="bg-black text-white p-4 font-mono"><pre>Workflow â†’ DO Room â†’ WebSocket â†’ Live UI
                â†“              â†“              â†“
            Event Model    Real-time Updates  Analytics Engine</pre></div></section></div></main> <section class="p-8"><div class="max-w-4xl mx-auto space-y-10"><div><h2 class="text-2xl font-bold font-mono mb-4">PATTERN OVERVIEW</h2> <div class="grid grid-cols-1 md:grid-cols-2 gap-6"><div class="border-2 border-black p-6"><h3 class="text-xl font-bold font-mono mb-4">TRADITIONAL APPROACH</h3> <ul class="space-y-2 text-sm"><li>â€¢ Polling for workflow status</li> <li>â€¢ No real-time updates</li> <li>â€¢ Limited error visibility</li> <li>â€¢ Expensive status checks</li> <li>â€¢ No historical analytics</li></ul></div> <div class="border-2 border-black p-6"><h3 class="text-xl font-bold font-mono mb-4">WORKFLOW LIVE APPROACH</h3> <ul class="space-y-2 text-sm"><li>â€¢ WebSocket-based live updates</li> <li>â€¢ Durable Object rooms per workflow</li> <li>â€¢ Real-time error streaming</li> <li>â€¢ Cost-effective monitoring</li> <li>â€¢ Analytics Engine integration</li></ul></div></div></div> <div><h2 class="text-2xl font-bold font-mono mb-4">KEY FEATURES</h2> <ul class="list-disc ml-6 space-y-1"><li><strong>Real-time updates</strong> - WebSocket streaming of workflow progress</li> <li><strong>Per-workflow rooms</strong> - Durable Object isolation for each
          workflow</li> <li><strong>Event-driven architecture</strong> - Clean separation of concerns</li> <li><strong>Error handling</strong> - Automatic retries and failure notifications</li> <li><strong>Analytics integration</strong> - Historical data with Analytics
          Engine</li> <li><strong>Minimal latency</strong> - Sub-second update propagation</li> <li><strong>Scalable design</strong> - Handles thousands of concurrent workflows</li></ul></div> <div><h2 class="text-2xl font-bold font-mono mb-4">DEMO</h2> <div class="bg-black text-white p-4 font-mono mb-4"><pre>Try it live at: workflow-live.coey.dev</pre></div> <p class="text-sm text-gray-600">Real-time workflow monitoring with live stages, errors, and durations
        under 1 second.</p></div> <div><h2 class="text-2xl font-bold font-mono mb-4">WORKFLOW MONITOR</h2> <div class="border-2 border-black"><h3 class="px-4 py-2 border-b-2 border-black font-bold font-mono">Core Workflow Monitoring Logic</h3> <!--[!--><pre class="bg-black border-2 border-black p-4 overflow-x-auto text-white"><code>// src/lib/workflow-monitor.ts
export interface WorkflowStage {
  id: string;
  name: string;
  status: 'pending' | 'running' | 'completed' | 'failed';
  startTime?: number;
  endTime?: number;
  duration?: number;
  error?: string;
  data?: any;
}

export interface Workflow {
  id: string;
  name: string;
  status: 'pending' | 'running' | 'completed' | 'failed';
  stages: WorkflowStage[];
  startTime: number;
  endTime?: number;
  duration?: number;
  error?: string;
  metadata?: any;
}

export class WorkflowMonitor {
  private workflows = new Map&lt;string, Workflow>();
  private eventHandlers = new Map&lt;string, Set&lt;(workflow: Workflow) => void>>();

  constructor(private env: any) {}

  async createWorkflow(name: string, stages: Omit&lt;WorkflowStage, 'id' | 'status'>[]): Promise&lt;Workflow> {
    const id = crypto.randomUUID();
    const workflow: Workflow = {
      id,
      name,
      status: 'pending',
      stages: stages.map(stage => ({
        ...stage,
        id: crypto.randomUUID(),
        status: 'pending'
      })),
      startTime: Date.now()
    };

    this.workflows.set(id, workflow);
    await this.broadcastUpdate(workflow);
    
    return workflow;
  }

  async startWorkflow(id: string): Promise&lt;Workflow> {
    const workflow = this.workflows.get(id);
    if (!workflow) {
      throw new Error(`Workflow ${id} not found`);
    }

    workflow.status = 'running';
    await this.broadcastUpdate(workflow);
    
    return workflow;
  }

  async updateStage(workflowId: string, stageId: string, updates: Partial&lt;WorkflowStage>): Promise&lt;Workflow> {
    const workflow = this.workflows.get(workflowId);
    if (!workflow) {
      throw new Error(`Workflow ${workflowId} not found`);
    }

    const stage = workflow.stages.find(s => s.id === stageId);
    if (!stage) {
      throw new Error(`Stage ${stageId} not found in workflow ${workflowId}`);
    }

    // Update stage
    Object.assign(stage, updates);
    
    if (updates.status === 'running' &amp;&amp; !stage.startTime) {
      stage.startTime = Date.now();
    }
    
    if (updates.status === 'completed' || updates.status === 'failed') {
      stage.endTime = Date.now();
      stage.duration = stage.endTime - (stage.startTime || stage.endTime);
    }

    // Update workflow status based on stages
    this.updateWorkflowStatus(workflow);
    
    await this.broadcastUpdate(workflow);
    
    return workflow;
  }

  async completeWorkflow(id: string, error?: string): Promise&lt;Workflow> {
    const workflow = this.workflows.get(id);
    if (!workflow) {
      throw new Error(`Workflow ${id} not found`);
    }

    workflow.status = error ? 'failed' : 'completed';
    workflow.endTime = Date.now();
    workflow.duration = workflow.endTime - workflow.startTime;
    workflow.error = error;

    await this.broadcastUpdate(workflow);
    
    return workflow;
  }

  getWorkflow(id: string): Workflow | undefined {
    return this.workflows.get(id);
  }

  getAllWorkflows(): Workflow[] {
    return Array.from(this.workflows.values());
  }

  subscribe(workflowId: string, handler: (workflow: Workflow) => void): () => void {
    if (!this.eventHandlers.has(workflowId)) {
      this.eventHandlers.set(workflowId, new Set());
    }
    
    this.eventHandlers.get(workflowId)!.add(handler);
    
    // Return unsubscribe function
    return () => {
      const handlers = this.eventHandlers.get(workflowId);
      if (handlers) {
        handlers.delete(handler);
        if (handlers.size === 0) {
          this.eventHandlers.delete(workflowId);
        }
      }
    };
  }

  private updateWorkflowStatus(workflow: Workflow): void {
    const stages = workflow.stages;
    
    if (stages.every(s => s.status === 'completed')) {
      workflow.status = 'completed';
    } else if (stages.some(s => s.status === 'failed')) {
      workflow.status = 'failed';
    } else if (stages.some(s => s.status === 'running')) {
      workflow.status = 'running';
    } else {
      workflow.status = 'pending';
    }
  }

  private async broadcastUpdate(workflow: Workflow): Promise&lt;void> {
    const handlers = this.eventHandlers.get(workflow.id);
    if (handlers) {
      for (const handler of handlers) {
        try {
          handler(workflow);
        } catch (error) {
          console.error('Error in workflow event handler:', error);
        }
      }
    }

    // Send to Analytics Engine for historical data
    await this.sendToAnalytics(workflow);
  }

  private async sendToAnalytics(workflow: Workflow): Promise&lt;void> {
    try {
      await this.env.ANALYTICS_ENGINE.writeDataPoint({
        blobs: [workflow.id, workflow.name, workflow.status],
        doubles: [workflow.duration || 0, workflow.stages.length],
        indexes: [workflow.name, workflow.status]
      });
    } catch (error) {
      console.error('Failed to send workflow data to Analytics Engine:', error);
    }
  }
}</code></pre><!--]--><!----></div></div> <div><h2 class="text-2xl font-bold font-mono mb-4">DURABLE OBJECT ROOM</h2> <div class="border-2 border-black"><h3 class="px-4 py-2 border-b-2 border-black font-bold font-mono">WebSocket Connection Management</h3> <!--[!--><pre class="bg-black border-2 border-black p-4 overflow-x-auto text-white"><code>// src/durable-objects/WorkflowRoom.ts
import { DurableObject } from "cloudflare:workers";

export class WorkflowRoom extends DurableObject {
  private connections = new Set&lt;WebSocket>();
  private workflowId: string | null = null;

  async fetch(request: Request): Promise&lt;Response> {
    const url = new URL(request.url);
    
    if (request.headers.get("Upgrade") === "websocket") {
      return this.handleWebSocket(request);
    }
    
    if (url.pathname === "/join") {
      return this.handleJoin(request);
    }
    
    if (url.pathname === "/broadcast") {
      return this.handleBroadcast(request);
    }

    return new Response("Not found", { status: 404 });
  }

  private async handleWebSocket(request: Request): Promise&lt;Response> {
    const webSocketPair = new WebSocketPair();
    const [client, server] = Object.values(webSocketPair);

    server.accept();
    this.connections.add(server);

    // Handle WebSocket events
    server.addEventListener("message", (event) => {
      try {
        const data = JSON.parse(event.data as string);
        this.handleWebSocketMessage(server, data);
      } catch (error) {
        console.error("Error parsing WebSocket message:", error);
        server.send(JSON.stringify({ error: "Invalid message format" }));
      }
    });

    server.addEventListener("close", () => {
      this.connections.delete(server);
    });

    server.addEventListener("error", (error) => {
      console.error("WebSocket error:", error);
      this.connections.delete(server);
    });

    // Send welcome message
    server.send(JSON.stringify({
      type: "connected",
      workflowId: this.workflowId,
      timestamp: Date.now()
    }));

    return new Response(null, {
      status: 101,
      webSocket: client
    });
  }

  private async handleJoin(request: Request): Promise&lt;Response> {
    const { workflowId } = await request.json();
    
    if (!workflowId) {
      return new Response("Missing workflowId", { status: 400 });
    }

    this.workflowId = workflowId;
    
    // Broadcast join event to all connections
    this.broadcast({
      type: "workflow_joined",
      workflowId,
      timestamp: Date.now()
    });

    return new Response(JSON.stringify({ success: true }), {
      headers: { "Content-Type": "application/json" }
    });
  }

  private async handleBroadcast(request: Request): Promise&lt;Response> {
    const data = await request.json();
    
    this.broadcast({
      type: "workflow_update",
      data,
      timestamp: Date.now()
    });

    return new Response(JSON.stringify({ success: true }), {
      headers: { "Content-Type": "application/json" }
    });
  }

  private handleWebSocketMessage(server: WebSocket, data: any): void {
    switch (data.type) {
      case "ping":
        server.send(JSON.stringify({ type: "pong", timestamp: Date.now() }));
        break;
      case "subscribe":
        // Handle subscription to specific workflow events
        break;
      default:
        server.send(JSON.stringify({ error: "Unknown message type" }));
    }
  }

  private broadcast(message: any): void {
    const messageStr = JSON.stringify(message);
    
    for (const connection of this.connections) {
      try {
        connection.send(messageStr);
      } catch (error) {
        console.error("Error broadcasting message:", error);
        this.connections.delete(connection);
      }
    }
  }

  // Called by external systems to broadcast workflow updates
  async broadcastWorkflowUpdate(workflow: any): Promise&lt;void> {
    this.broadcast({
      type: "workflow_update",
      workflow,
      timestamp: Date.now()
    });
  }

  // Called by external systems to broadcast stage updates
  async broadcastStageUpdate(workflowId: string, stage: any): Promise&lt;void> {
    this.broadcast({
      type: "stage_update",
      workflowId,
      stage,
      timestamp: Date.now()
    });
  }

  // Called by external systems to broadcast errors
  async broadcastError(workflowId: string, error: any): Promise&lt;void> {
    this.broadcast({
      type: "workflow_error",
      workflowId,
      error,
      timestamp: Date.now()
    });
  }
}</code></pre><!--]--><!----></div></div> <div><h2 class="text-2xl font-bold font-mono mb-4">WORKER IMPLEMENTATION</h2> <div class="border-2 border-black"><h3 class="px-4 py-2 border-b-2 border-black font-bold font-mono">HTTP/WebSocket Routing and Workflow Execution</h3> <!--[!--><pre class="bg-black border-2 border-black p-4 overflow-x-auto text-white"><code>// src/worker.ts
import { WorkflowRoom } from "./durable-objects/WorkflowRoom";
import { WorkflowMonitor } from "./lib/workflow-monitor";

export default {
  async fetch(request: Request, env: any): Promise&lt;Response> {
    const url = new URL(request.url);
    
    // CORS headers
    const corsHeaders = {
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
      "Access-Control-Allow-Headers": "Content-Type, Authorization"
    };

    if (request.method === "OPTIONS") {
      return new Response(null, { headers: corsHeaders });
    }

    try {
      // Route to appropriate handler
      if (url.pathname.startsWith("/workflow/")) {
        return handleWorkflowRequest(request, env, corsHeaders);
      } else if (url.pathname.startsWith("/room/")) {
        return handleRoomRequest(request, env, corsHeaders);
      } else if (url.pathname === "/") {
        return new Response("Workflow Live API", { headers: corsHeaders });
      }

      return new Response("Not found", { status: 404, headers: corsHeaders });
    } catch (error) {
      console.error("Worker error:", error);
      return new Response("Internal server error", { 
        status: 500, 
        headers: corsHeaders 
      });
    }
  }
};

async function handleWorkflowRequest(request: Request, env: any, corsHeaders: any): Promise&lt;Response> {
  const url = new URL(request.url);
  const pathParts = url.pathname.split("/");
  const workflowId = pathParts[2];
  const action = pathParts[3];

  const monitor = new WorkflowMonitor(env);

  switch (request.method) {
    case "POST":
      if (action === "create") {
        const { name, stages } = await request.json();
        const workflow = await monitor.createWorkflow(name, stages);
        return new Response(JSON.stringify(workflow), {
          headers: { ...corsHeaders, "Content-Type": "application/json" }
        });
      } else if (action === "start") {
        const workflow = await monitor.startWorkflow(workflowId);
        return new Response(JSON.stringify(workflow), {
          headers: { ...corsHeaders, "Content-Type": "application/json" }
        });
      }
      break;

    case "PUT":
      if (action === "stage") {
        const { stageId, updates } = await request.json();
        const workflow = await monitor.updateStage(workflowId, stageId, updates);
        
        // Broadcast to room
        const roomId = env.WORKFLOW_ROOM.idFromName(workflowId);
        const room = env.WORKFLOW_ROOM.get(roomId);
        await room.broadcastStageUpdate(workflowId, updates);
        
        return new Response(JSON.stringify(workflow), {
          headers: { ...corsHeaders, "Content-Type": "application/json" }
        });
      } else if (action === "complete") {
        const { error } = await request.json();
        const workflow = await monitor.completeWorkflow(workflowId, error);
        
        // Broadcast to room
        const roomId = env.WORKFLOW_ROOM.idFromName(workflowId);
        const room = env.WORKFLOW_ROOM.get(roomId);
        await room.broadcastWorkflowUpdate(workflow);
        
        return new Response(JSON.stringify(workflow), {
          headers: { ...corsHeaders, "Content-Type": "application/json" }
        });
      }
      break;

    case "GET":
      if (action === "status") {
        const workflow = monitor.getWorkflow(workflowId);
        if (!workflow) {
          return new Response("Workflow not found", { 
            status: 404, 
            headers: corsHeaders 
          });
        }
        return new Response(JSON.stringify(workflow), {
          headers: { ...corsHeaders, "Content-Type": "application/json" }
        });
      } else if (!action) {
        // Get all workflows
        const workflows = monitor.getAllWorkflows();
        return new Response(JSON.stringify(workflows), {
          headers: { ...corsHeaders, "Content-Type": "application/json" }
        });
      }
      break;
  }

  return new Response("Method not allowed", { status: 405, headers: corsHeaders });
}

async function handleRoomRequest(request: Request, env: any, corsHeaders: any): Promise&lt;Response> {
  const url = new URL(request.url);
  const pathParts = url.pathname.split("/");
  const workflowId = pathParts[2];
  const action = pathParts[3];

  if (!workflowId) {
    return new Response("Missing workflow ID", { status: 400, headers: corsHeaders });
  }

  const roomId = env.WORKFLOW_ROOM.idFromName(workflowId);
  const room = env.WORKFLOW_ROOM.get(roomId);

  if (action === "join") {
    return room.fetch(new Request("/join", {
      method: "POST",
      body: JSON.stringify({ workflowId })
    }));
  } else if (action === "websocket") {
    return room.fetch(request);
  }

  return new Response("Not found", { status: 404, headers: corsHeaders });
}</code></pre><!--]--><!----></div></div> <div><h2 class="text-2xl font-bold font-mono mb-4">FRONTEND COMPONENT</h2> <div class="border-2 border-black"><h3 class="px-4 py-2 border-b-2 border-black font-bold font-mono">Real-time UI with WebSocket Updates</h3> <!--[!--><pre class="bg-black border-2 border-black p-4 overflow-x-auto text-white"><code>&lt;!-- src/static/index.html -->
&lt;!DOCTYPE html>
&lt;html lang="en">
&lt;head>
    &lt;meta charset="UTF-8">
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0">
    &lt;title>Workflow Live Monitor&lt;/title>
    &lt;style>
        body {
            font-family: 'Courier New', monospace;
            background: #000;
            color: #0f0;
            margin: 0;
            padding: 20px;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            border-bottom: 2px solid #0f0;
            padding-bottom: 20px;
        }
        
        .workflow-list {
            display: grid;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .workflow-card {
            border: 1px solid #0f0;
            padding: 20px;
            background: #001100;
        }
        
        .workflow-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .workflow-name {
            font-size: 1.2em;
            font-weight: bold;
        }
        
        .workflow-status {
            padding: 5px 10px;
            border: 1px solid #0f0;
            background: #002200;
        }
        
        .workflow-status.running {
            background: #004400;
            animation: pulse 2s infinite;
        }
        
        .workflow-status.completed {
            background: #006600;
        }
        
        .workflow-status.failed {
            background: #660000;
            color: #ff0000;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .stages {
            margin-top: 15px;
        }
        
        .stage {
            display: flex;
            align-items: center;
            margin: 8px 0;
            padding: 8px;
            border-left: 3px solid #333;
        }
        
        .stage.running {
            border-left-color: #0f0;
            background: #001100;
        }
        
        .stage.completed {
            border-left-color: #0f0;
            background: #002200;
        }
        
        .stage.failed {
            border-left-color: #f00;
            background: #220000;
        }
        
        .stage-name {
            flex: 1;
        }
        
        .stage-duration {
            color: #666;
            font-size: 0.9em;
        }
        
        .controls {
            text-align: center;
            margin-bottom: 30px;
        }
        
        button {
            background: #000;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 10px 20px;
            margin: 0 10px;
            cursor: pointer;
            font-family: inherit;
        }
        
        button:hover {
            background: #001100;
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .error {
            color: #f00;
            background: #220000;
            padding: 10px;
            border: 1px solid #f00;
            margin: 10px 0;
        }
        
        .connection-status {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 5px 10px;
            border: 1px solid #0f0;
            background: #001100;
        }
        
        .connection-status.disconnected {
            border-color: #f00;
            background: #220000;
            color: #f00;
        }
    &lt;/style>
&lt;/head>
&lt;body>
    &lt;div class="container">
        &lt;div class="header">
            &lt;h1>ðŸš€ WORKFLOW LIVE MONITOR&lt;/h1>
            &lt;p>Real-time workflow monitoring powered by Cloudflare Workers &amp; Durable Objects&lt;/p>
        &lt;/div>
        
        &lt;div class="connection-status" id="connectionStatus">
            Connecting...
        &lt;/div>
        
        &lt;div class="controls">
            &lt;button onclick="createSampleWorkflow()">Create Sample Workflow&lt;/button>
            &lt;button onclick="startAllWorkflows()">Start All Workflows&lt;/button>
            &lt;button onclick="clearWorkflows()">Clear All&lt;/button>
        &lt;/div>
        
        &lt;div id="errorContainer">&lt;/div>
        
        &lt;div class="workflow-list" id="workflowList">
            &lt;!-- Workflows will be populated here -->
        &lt;/div>
    &lt;/div>

    &lt;script>
        class WorkflowMonitor {
            constructor() {
                this.workflows = new Map();
                this.websocket = null;
                this.connectionStatus = document.getElementById('connectionStatus');
                this.workflowList = document.getElementById('workflowList');
                this.errorContainer = document.getElementById('errorContainer');
                
                this.connect();
            }
            
            connect() {
                try {
                    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                    const wsUrl = `${protocol}//${window.location.host}/room/${crypto.randomUUID()}/websocket`;
                    
                    this.websocket = new WebSocket(wsUrl);
                    
                    this.websocket.onopen = () => {
                        this.connectionStatus.textContent = 'Connected';
                        this.connectionStatus.className = 'connection-status';
                    };
                    
                    this.websocket.onmessage = (event) => {
                        const data = JSON.parse(event.data);
                        this.handleMessage(data);
                    };
                    
                    this.websocket.onclose = () => {
                        this.connectionStatus.textContent = 'Disconnected';
                        this.connectionStatus.className = 'connection-status disconnected';
                        
                        // Reconnect after 3 seconds
                        setTimeout(() => this.connect(), 3000);
                    };
                    
                    this.websocket.onerror = (error) => {
                        console.error('WebSocket error:', error);
                        this.showError('WebSocket connection error');
                    };
                    
                } catch (error) {
                    console.error('Failed to connect:', error);
                    this.showError('Failed to connect to workflow monitor');
                }
            }
            
            handleMessage(data) {
                switch (data.type) {
                    case 'connected':
                        console.log('Connected to workflow monitor');
                        break;
                    case 'workflow_update':
                        this.updateWorkflow(data.workflow);
                        break;
                    case 'stage_update':
                        this.updateStage(data.workflowId, data.stage);
                        break;
                    case 'workflow_error':
                        this.showError(`Workflow ${data.workflowId} error: ${data.error.message}`);
                        break;
                }
            }
            
            async createSampleWorkflow() {
                try {
                    const response = await fetch('/workflow/create', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            name: `Sample Workflow ${Date.now()}`,
                            stages: [
                                { name: 'Initialize' },
                                { name: 'Process Data' },
                                { name: 'Validate Results' },
                                { name: 'Send Notifications' },
                                { name: 'Cleanup' }
                            ]
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    const workflow = await response.json();
                    this.workflows.set(workflow.id, workflow);
                    this.renderWorkflows();
                    
                    // Join the workflow room
                    await this.joinWorkflowRoom(workflow.id);
                    
                } catch (error) {
                    this.showError(`Failed to create workflow: ${error.message}`);
                }
            }
            
            async joinWorkflowRoom(workflowId) {
                try {
                    await fetch(`/room/${workflowId}/join`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ workflowId })
                    });
                } catch (error) {
                    console.error('Failed to join workflow room:', error);
                }
            }
            
            async startAllWorkflows() {
                for (const [id, workflow] of this.workflows) {
                    if (workflow.status === 'pending') {
                        await this.startWorkflow(id);
                    }
                }
            }
            
            async startWorkflow(workflowId) {
                try {
                    const response = await fetch(`/workflow/${workflowId}/start`, {
                        method: 'POST'
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    const workflow = await response.json();
                    this.workflows.set(workflowId, workflow);
                    this.renderWorkflows();
                    
                    // Simulate workflow execution
                    this.simulateWorkflowExecution(workflowId);
                    
                } catch (error) {
                    this.showError(`Failed to start workflow: ${error.message}`);
                }
            }
            
            simulateWorkflowExecution(workflowId) {
                const workflow = this.workflows.get(workflowId);
                if (!workflow) return;
                
                let currentStageIndex = 0;
                
                const executeNextStage = async () => {
                    if (currentStageIndex >= workflow.stages.length) {
                        // Complete workflow
                        await this.completeWorkflow(workflowId);
                        return;
                    }
                    
                    const stage = workflow.stages[currentStageIndex];
                    
                    // Start stage
                    await this.updateStage(workflowId, stage.id, { status: 'running' });
                    
                    // Simulate work (random duration between 1-3 seconds)
                    const duration = Math.random() * 2000 + 1000;
                    
                    setTimeout(async () => {
                        // Complete stage (with occasional failure)
                        const shouldFail = Math.random() &lt; 0.1; // 10% failure rate
                        
                        if (shouldFail) {
                            await this.updateStage(workflowId, stage.id, { 
                                status: 'failed', 
                                error: 'Simulated failure' 
                            });
                            await this.completeWorkflow(workflowId, 'Stage failed');
                        } else {
                            await this.updateStage(workflowId, stage.id, { status: 'completed' });
                            currentStageIndex++;
                            executeNextStage();
                        }
                    }, duration);
                };
                
                executeNextStage();
            }
            
            async updateStage(workflowId, stageId, updates) {
                try {
                    const response = await fetch(`/workflow/${workflowId}/stage`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ stageId, updates })
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    const workflow = await response.json();
                    this.workflows.set(workflowId, workflow);
                    this.renderWorkflows();
                    
                } catch (error) {
                    this.showError(`Failed to update stage: ${error.message}`);
                }
            }
            
            async completeWorkflow(workflowId, error = null) {
                try {
                    const response = await fetch(`/workflow/${workflowId}/complete`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ error })
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    const workflow = await response.json();
                    this.workflows.set(workflowId, workflow);
                    this.renderWorkflows();
                    
                } catch (error) {
                    this.showError(`Failed to complete workflow: ${error.message}`);
                }
            }
            
            updateWorkflow(workflow) {
                this.workflows.set(workflow.id, workflow);
                this.renderWorkflows();
            }
            
            renderWorkflows() {
                this.workflowList.innerHTML = '';
                
                for (const [id, workflow] of this.workflows) {
                    const workflowCard = document.createElement('div');
                    workflowCard.className = 'workflow-card';
                    
                    const stagesHtml = workflow.stages.map(stage => `
                        &lt;div class="stage ${stage.status}">
                            &lt;div class="stage-name">${stage.name}&lt;/div>
                            &lt;div class="stage-duration">
                                ${stage.duration ? `${stage.duration}ms` : ''}
                                ${stage.error ? ` - ${stage.error}` : ''}
                            &lt;/div>
                        &lt;/div>
                    `).join('');
                    
                    workflowCard.innerHTML = `
                        &lt;div class="workflow-header">
                            &lt;div class="workflow-name">${workflow.name}&lt;/div>
                            &lt;div class="workflow-status ${workflow.status}">${workflow.status.toUpperCase()}&lt;/div>
                        &lt;/div>
                        &lt;div class="stages">
                            ${stagesHtml}
                        &lt;/div>
                    `;
                    
                    this.workflowList.appendChild(workflowCard);
                }
            }
            
            showError(message) {
                const errorDiv = document.createElement('div');
                errorDiv.className = 'error';
                errorDiv.textContent = message;
                this.errorContainer.appendChild(errorDiv);
                
                // Remove error after 5 seconds
                setTimeout(() => {
                    if (errorDiv.parentNode) {
                        errorDiv.parentNode.removeChild(errorDiv);
                    }
                }, 5000);
            }
            
            clearWorkflows() {
                this.workflows.clear();
                this.renderWorkflows();
            }
        }
        
        // Initialize the monitor
        const monitor = new WorkflowMonitor();
        
        // Global functions for buttons
        window.createSampleWorkflow = () => monitor.createSampleWorkflow();
        window.startAllWorkflows = () => monitor.startAllWorkflows();
        window.clearWorkflows = () => monitor.clearWorkflows();
    &lt;/script>
&lt;/body>
&lt;/html></code></pre><!--]--><!----></div></div> <div><h2 class="text-2xl font-bold font-mono mb-4">WRANGLER CONFIG</h2> <div class="border-2 border-black"><h3 class="px-4 py-2 border-b-2 border-black font-bold font-mono">Cloudflare Workers Configuration</h3> <!--[!--><pre class="bg-black border-2 border-black p-4 overflow-x-auto text-white"><code># wrangler.toml
name = "workflow-live"
main = "src/worker.ts"
compatibility_date = "2024-01-15"
compatibility_flags = ["nodejs_compat"]

[durable_objects]
bindings = [
  { name = "WORKFLOW_ROOM", class_name = "WorkflowRoom" }
]

[[durable_objects.migrations]]
tag = "v1"
new_classes = ["WorkflowRoom"]

[analytics_engine_datasets]
bindings = [
  { name = "ANALYTICS_ENGINE", dataset = "workflow_analytics" }
]

[vars]
ENVIRONMENT = "production"

# Development
[env.development]
vars = { ENVIRONMENT = "development" }

# Production
[env.production]
vars = { ENVIRONMENT = "production" }</code></pre><!--]--><!----></div></div> <div><h2 class="text-2xl font-bold font-mono mb-4">ARCHITECTURE PATTERNS</h2> <div class="grid grid-cols-1 md:grid-cols-2 gap-6"><div class="border-2 border-black p-4"><h4 class="font-bold font-mono mb-3">WORKFLOW EXECUTION</h4> <ul class="text-sm space-y-1"><li>â€¢ Worker handles HTTP/WebSocket routing</li> <li>â€¢ Manages workflow execution</li> <li>â€¢ Broadcasts updates via Durable Object</li> <li>â€¢ Handles failures gracefully</li></ul></div> <div class="border-2 border-black p-4"><h4 class="font-bold font-mono mb-3">CONNECTION MANAGEMENT</h4> <ul class="text-sm space-y-1"><li>â€¢ Durable Object manages WebSocket connections</li> <li>â€¢ Handles broadcast messaging</li> <li>â€¢ Maintains connection state</li> <li>â€¢ Per-workflow room isolation</li></ul></div> <div class="border-2 border-black p-4"><h4 class="font-bold font-mono mb-3">REAL-TIME UPDATES</h4> <ul class="text-sm space-y-1"><li>â€¢ Simple, accessible UI</li> <li>â€¢ Real-time status updates</li> <li>â€¢ Error handling and retries</li> <li>â€¢ Visual progress feedback</li></ul></div> <div class="border-2 border-black p-4"><h4 class="font-bold font-mono mb-3">ANALYTICS INTEGRATION</h4> <ul class="text-sm space-y-1"><li>â€¢ Analytics Engine for history</li> <li>â€¢ Event model for data collection</li> <li>â€¢ Historical workflow analysis</li> <li>â€¢ Performance metrics tracking</li></ul></div></div></div> <div><h2 class="text-2xl font-bold font-mono mb-4">WORKFLOW TYPES</h2> <ul class="list-disc ml-6 space-y-1"><li><strong>AI Agent workflows</strong> - Monitor agent execution and decision
          making</li> <li><strong>Data processing pipelines</strong> - Track ETL jobs and transformations</li> <li><strong>User onboarding flows</strong> - Monitor multi-step user journeys</li> <li><strong>Background jobs</strong> - Track long-running tasks and cleanup</li> <li><strong>Integration workflows</strong> - Monitor API calls and data sync</li> <li><strong>Deployment pipelines</strong> - Track build and deployment stages</li> <li><strong>Business processes</strong> - Monitor approval workflows and notifications</li></ul></div> <div><h2 class="text-2xl font-bold font-mono mb-4">PERFORMANCE CHARACTERISTICS</h2> <ul class="list-disc ml-6 space-y-1"><li><strong>Update latency:</strong> &lt;100ms for WebSocket events</li> <li><strong>Workflow execution:</strong> Sub-second stage transitions</li> <li><strong>Connection handling:</strong> 1000+ concurrent WebSocket connections</li> <li><strong>Error detection:</strong> Real-time failure notifications</li> <li><strong>Analytics ingestion:</strong> High-throughput event streaming</li> <li><strong>Global distribution:</strong> 200+ edge locations</li></ul></div> <div><h2 class="text-2xl font-bold font-mono mb-4">USE CASES</h2> <ul class="list-disc ml-6 space-y-1"><li>AI Agent monitoring and control with real-time decision tracking</li> <li>Edge computing mini-apps with live status updates</li> <li>Real-time workflow orchestration for complex business processes</li> <li>Live system monitoring with instant failure alerts</li> <li>Interactive edge applications with user feedback</li> <li>Data pipeline monitoring with stage-by-stage visibility</li> <li>Multi-step form processing with progress tracking</li></ul></div> <div><h2 class="text-2xl font-bold font-mono mb-4">QUICK START</h2> <div class="bg-black text-white p-4 font-mono mb-4"><pre># Clone the repo
git clone https://github.com/acoyfellow/workflow-live
cd workflow-live

# Install dependencies 
bun install

# Configure Cloudflare
wrangler login

# Deploy
bun run deploy</pre></div> <p class="text-sm text-gray-600">Creates a complete workflow monitoring system with real-time updates and
        analytics.</p></div> <div><h2 class="text-2xl font-bold font-mono mb-4">DEVELOPMENT WORKFLOW</h2> <ol class="list-decimal ml-6 space-y-2"><li><strong>Local Development:</strong> <code>bun run dev</code> starts local
          Workers and WebSocket server</li> <li><strong>Workflow Definition:</strong> Define workflow stages and error
          handling</li> <li><strong>Testing:</strong> <code>bun run test</code> runs unit and integration
          tests</li> <li><strong>Deployment:</strong> <code>bun run deploy</code> pushes to Cloudflare</li> <li><strong>Monitoring:</strong> Real-time metrics in Cloudflare dashboard</li></ol></div> <div class="border-t-2 border-black pt-6"><h3 class="text-xl font-bold font-mono mb-2">Related patterns</h3> <ul class="list-disc ml-6"><li><a class="underline" href="/userdo">UserDO: Per-user Durable Objects</a></li> <li><a class="underline" href="/tenancy-isolation">Tenancy Isolation: Multi-tenant rate limiting</a></li> <li><a class="underline" href="/fleet-pattern">Fleet Pattern: Hierarchical Durable Objects</a></li> <li><a class="underline" href="/cache-sync">Cache Sync: Edge cache invalidation</a></li></ul></div></div></section><!----><!----></main><!----><!--]--> <!--[!--><!--]--><!--]-->
			
			<script>
				{
					__sveltekit_seuxg2 = {
						base: new URL(".", location).pathname.slice(0, -1)
					};

					const element = document.currentScript.parentElement;

					Promise.all([
						import("./_app/immutable/entry/start.B6XN_71n.js"),
						import("./_app/immutable/entry/app.BC487iTC.js")
					]).then(([kit, app]) => {
						kit.start(app, element, {
							node_ids: [0, 21],
							data: [{type:"data",data:{user:null,session:null},uses:{}},null],
							form: null,
							error: null
						});
					});
				}
			</script>
		</div>
	</body>
</html>
