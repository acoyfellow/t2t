ðŸ¤–">

 Email Agents: Why AI sitting in your inbox actually makes sense

 coey.dev POSTS ABOUT
 
 EMAIL AGENTS
 Why AI sitting in your inbox actually makes sense
 EMAIL AUTOMATION 2025.10.14
 THE EMAIL PROBLEM
 Average knowledge worker spends 2.6 hours per day on email.
 That's 13 hours per week. 28% of your working life.
 62% of those emails provide little to no value. Newsletters
 you don't read. Automated notifications. CCs you didn't need. Support requests
 that should've been routed elsewhere.
 You're spending 8+ hours per week on email triage. Sorting, archiving,
 deleting, forwarding. The actual important stuff? Maybe 20% of that
 time.
 Sources: McKinsey, Adobe Email Study

 THE OBVIOUS SOLUTION
 An AI agent that sits in your inbox. Reads your email. Handles the
 repetitive stuff. Only bugs you when it actually needs a human.
 Not a rules engine. Not a fancy filter system. An actual agent that
 understands context and can take actions.
 You tell it what to do in plain English. It does it. That's the concept.

 HOW SIMPLE IT CAN BE
 Entire agent config. No code, no flowcharts, just describe it.
 // The entire "config" for an email agent
const leadQualifierAgent = {
 name: "Sales Lead Qualifier",
 prompt: `
 You're a sales qualification assistant.
 
 When emails come in about pricing, demos, or quotes:
 - If it's from a company with >100 employees, forward to enterprise@company.com
 - If it's SMB, forward to sales@company.com
 - Reply with relevant case studies and pricing info
 - Mark as read
 `,
 triggers: [
 "subject contains: demo, pricing, interested, quote, proposal, sales, purchase",
 "from: leads@company.com"
 ]
};

// That's it. No flowcharts, no decision trees, no rules engine.
// Just describe what you want in plain language.
 That's it. You're describing behavior in natural language. The agent
 figures out the details.

 BEFORE/AFTER
 // BEFORE: You handle email manually

7:00 AM - Check email
7:05 AM - Delete 12 newsletters you never read
7:10 AM - Manually filter support requests to support team
7:15 AM - Forward sales inquiry to sales with context
7:20 AM - Respond to "what's the status of X" (could've checked Jira)
7:30 AM - Archive automated notifications you don't care about
7:35 AM - Actually start working

Total time on email before real work: 35 minutes
Actual valuable emails processed: 2

// AFTER: Agent handles the noise

7:00 AM - Check email
7:01 AM - See 2 emails that actually need human attention
7:05 AM - Actually start working

Agent handled:
- Deleted newsletters (learned which ones you ignore)
- Routed support requests (matched patterns from history)
- Forwarded sales inquiry with enriched context
- Replied to status check with Jira link
- Archived notifications (you never click them)

Time saved: 30 minutes
Same outcome, zero grunt work

 THE MATH ON EMAIL WASTE
 TIME SPENT
 2.6 hours/day
 on email (McKinsey)

 121 emails/day
 average received

 28% of work week
 spent in inbox

 THE WASTE
 62% low value
 provide little to no value (Adobe)

 75 emails/day
 that could be auto-handled

 51 minutes/day
 on pure email triage

 THE CALCULATION 121 emails/day Ã— 62% low-value = 75 emails
 75 emails Ã— (11s read + 30s triage) = 51 minutes
 51 min/day Ã— 5 days = 4.25 hours/week on noise

 WHAT AN AGENT CAN DO
 Basic actions + external integrations. That's where it gets interesting.
 // What an email agent can actually do

interface EmailAgent {
 // Basic filtering
 read(criteria: string): Email[];
 
 // Actions
 reply(email: Email, message: string): void;
 forward(email: Email, to: string, context?: string): void;
 archive(email: Email): void;
 delete(email: Email): void;
 label(email: Email, labels: string[]): void;
 
 // External integrations
 searchKnowledgeBase(query: string): SearchResults;
 lookupCRM(email: string): CustomerData;
 createTicket(email: Email): TicketID;
 checkCalendar(timeRange: string): Availability;
 
 // Learning
 learnFromActions(userAction: Action): void;
}

// Example: Support routing agent
const agent = {
 prompt: `
 Read emails sent to support@company.com.
 
 If it's a bug report:
 - Create Jira ticket
 - Reply with ticket number
 - Forward to engineering@company.com
 
 If it's a billing question:
 - Check Stripe for customer status
 - Reply with account info or forward to billing@company.com
 
 If it's a feature request:
 - Add to feature request database
 - Reply acknowledging and link to roadmap
 
 If unsure, forward to support@company.com for human review.
 `
};

 MCP: CONNECT EXTERNAL TOOLS
 Model Context Protocol. Agent calls APIs.
 Your agent isn't limited to email actions. It can check your calendar,
 look up customers in CRM, create tickets, search docs. Anything with an
 API or MCP server.
 // MCP: Model Context Protocol integration
// Your agent can call external tools

// Example: Email agent with calendar access
{
 "name": "Meeting Scheduler",
 "prompt": "When people ask to schedule meetings, check my calendar and propose 3 available times in their timezone.",
 "mcpServers": [
 {
 "name": "google-calendar",
 "endpoint": "mcp://calendar.google.com"
 },
 {
 "name": "timezone-converter",
 "endpoint": "mcp://worldtime.api"
 }
 ]
}

// The agent can now:
// 1. Read email: "Can we meet next week?"
// 2. Call calendar MCP: getAvailability(nextWeek)
// 3. Call timezone MCP: convert(times, theirTimezone)
// 4. Reply: "I'm available Tuesday 2pm, Wednesday 10am, or Thursday 3pm your time"

// No code. Just connected the tools.
 You just describe what you want. "Check my calendar and propose times."
 Agent figures out how to call the calendar API.

 FILES AS KNOWLEDGE BASE
 Upload docs. Agent uses them to answer.
 Give your agent product docs, pricing sheets, case studies, FAQs. When
 customers ask questions, agent searches the files and responds with
 actual information.
 // Upload files to give agent domain knowledge

// Example: Customer support agent
const agent = {
 name: "Support Bot",
 files: [
 "product-documentation.pdf",
 "common-issues.md",
 "pricing-tiers.csv",
 "case-studies.pdf"
 ],
 prompt: `
 Answer customer questions using the uploaded documentation.
 If the answer isn't in the docs, forward to support@company.com.
 Always be helpful and cite which document you pulled info from.
 `
};

// Now when customer asks "How do I reset my password?":
// - Agent searches product-documentation.pdf
// - Finds the reset flow
// - Replies with step-by-step instructions
// - Cites page 47 of product docs

// Knowledge base without building a knowledge base

 LEARNING FROM HISTORY
 Agent watches what you do. Learns patterns.
 You manually handle email for a week. Agent observes. "You always delete
 newsletters from X." "You always forward support emails to Y." Then it
 starts suggesting those actions. Eventually, automates them.
 // Agent learns from your behavior

// Week 1: You manually handle everything
emailAgent.observe({
 from: "newsletter@startup.com",
 action: "delete",
 frequency: "always"
});

emailAgent.observe({
 from: "support@product.com",
 subject: "contains: urgent",
 action: "forward to team@company.com",
 frequency: "always"
});

// Week 2: Agent starts suggesting actions
emailAgent.suggest({
 email: newEmail,
 suggestion: "Delete? You always delete emails from this sender.",
 confidence: 0.95
});

// Week 4: Agent auto-handles with your patterns
emailAgent.automate({
 pattern: "newsletters you never read",
 action: "delete",
 enabled: true,
 overrideAvailable: true // You can undo
});

// It's learning your triage patterns

 COMPLEX WORKFLOWS
 Multi-step, conditional, integrated.
 Real workflows aren't "if X then Y." They're "if X, check Y, then
 depending on Z, do A or B, and also update C." Agent can handle that.
 // Complex workflow example: Lead qualification

const leadAgent = {
 prompt: `
 When emails mention pricing, demos, or buying:
 
 1. Extract company info from email signature
 2. Look up company size on Clearbit API
 3. Check if they're already in our CRM
 4. If existing customer:
 - Reply with account manager contact
 - CC account manager
 5. If new lead:
 - If enterprise (>100 employees):
 * Add to Salesforce as high-value lead
 * Forward to enterprise@company.com with enriched data
 - If SMB:
 * Add to Salesforce as standard lead 
 * Reply with self-service demo link and pricing
 * Forward to sales@company.com
 6. If company size unknown:
 - Forward to sales@company.com for manual review
 `,
 integrations: ["clearbit", "salesforce", "gmail"],
 files: ["pricing-sheet.pdf", "case-studies.pdf"]
};

// This runs on every inbound lead email
// Handles 80% automatically
// Human reviews the 20% that need judgment
 This used to require Zapier chains or custom code. Now it's a paragraph
 of instructions.

 REAL-WORLD USE CASES
 // Real-world email agent examples

// 1. NEWSLETTER CURATOR
{
 name: "Newsletter Filter",
 prompt: `
 I get 20+ newsletters daily. Most I never read.
 
 Archive these immediately:
 - Any newsletter I haven't clicked in 30 days
 - Promotional emails disguised as newsletters
 - "Weekly roundup" emails (I never have time)
 
 Keep in inbox:
 - Technical deep-dives (I always read these)
 - Industry analysis from specific authors
 - Anything mentioning technologies I'm currently using
 
 Move to "Read Later" folder:
 - Long-form content that looks interesting
 - Topics related to current projects
 `
}

// 2. RECRUITER AUTO-RESPONDER
{
 name: "Recruiter Handler", 
 prompt: `
 When recruiters email me:
 
 If they mention:
 - Remote work, interesting tech stack, senior role
 - Reply: "Thanks for reaching out. Send JD and comp range to [email]"
 
 If they're pushing generic roles or can't share comp:
 - Reply: "Not looking currently, but feel free to check back in 6 months"
 
 If they're from FAANG:
 - Forward to me for manual review
 `
}

// 3. EXPENSE REPORTER
{
 name: "Receipt Processor",
 prompt: `
 When I get purchase receipts:
 - Extract: merchant, date, amount, category
 - Add row to "Expenses 2025" Google Sheet
 - If over $500, forward to me for review
 - Otherwise just archive with label "processed"
 `,
 integrations: ["google-sheets"]
}

// 4. MEETING SCHEDULER
{
 name: "Calendar Assistant",
 prompt: `
 When people ask to meet:
 - Check my calendar for next 2 weeks
 - Propose 3 times that work
 - Consider their timezone (extract from signature)
 - Only suggest times between 10am-4pm my time
 - No meetings on Friday afternoons
 `,
 integrations: ["google-calendar", "timezone-api"]
}

// 5. CUSTOMER SUPPORT TRIAGER 
{
 name: "Support Router",
 prompt: `
 Emails to support@:
 
 Bug reports â†’ Create Jira ticket, reply with ticket #, forward to eng@
 Billing questions â†’ Look up in Stripe, reply with info or forward to billing@
 Feature requests â†’ Add to roadmap sheet, reply with "thanks, we'll consider it"
 "How do I..." â†’ Search docs, reply with link
 Everything else â†’ Forward to support@ for human
 `,
 integrations: ["jira", "stripe", "google-docs"],
 files: ["product-docs.pdf"]
}

 WHY THIS WORKS NOW
 This wasn't possible 2 years ago. The AI capabilities crossed the
 threshold where you can actually trust it with email.
 // Why email agents are suddenly viable

// THEN (2020):
// - GPT-3 couldn't follow complex instructions reliably
// - Context windows too small for email threads
// - No good way to connect external tools
// - Hallucination risk too high for automated actions

// NOW (2025):
// - Claude/GPT-4 can follow multi-step instructions accurately
// - 200K+ token context (entire email threads + docs)
// - MCP protocol for tool integration
// - Confidence scores for automated vs. human review
// - You can give it files as knowledge base

// The capabilities crossed the threshold where this actually works

const thresholdCrossed = {
 instructionFollowing: {
 before: "60% success on complex multi-step tasks",
 now: "95% success on same tasks"
 },
 contextUnderstanding: {
 before: "4K tokens (couple emails)",
 now: "200K tokens (hundreds of emails + docs)"
 },
 toolIntegration: {
 before: "Hardcode every API call",
 now: "MCP: describe tools in natural language"
 },
 reliability: {
 before: "Can't trust it unsupervised",
 now: "Can trust with oversight + confidence thresholds"
 }
};

 THE TRUST PROGRESSION
 WEEK 1: OBSERVATION Agent watches you handle email. Learns patterns. "You always archive
 emails from this sender." "You always forward support@ emails to
 your team."

 WEEK 2: SUGGESTIONS Agent starts suggesting actions. "Archive this? You always archive
 from this sender (95% confidence)." You approve or override. It
 learns from corrections.

 WEEK 3: SUPERVISED AUTOMATION Agent auto-handles high-confidence actions. Newsletters you never
 read â†’ auto-archive. Support routing â†’ auto-forward. You review what
 it did, can undo anything.

 WEEK 4+: AUTONOMOUS Agent handles routine stuff completely. Only surfaces the emails
 that need human judgment. You check the activity log occasionally to
 make sure it's behaving.

 Same pattern as trust broker. Start supervised, earn autonomy based on performance.

 INTERESTING IMPLICATIONS
 EMAIL BECOMES ASYNC API
 Right now: email is for humans. You send email, human reads it,
 human responds.
 With agents: email becomes agent-to-agent communication. Your agent
 emails their agent. Agents negotiate, extract info, route to humans
 when needed.
 Email UI might not even be the primary interface. Just an activity
 log of what your agent did.

 INBOX ZERO BECOMES AUTOMATIC
 Inbox zero is a meme because it's manually impossible. 121 emails
 per day, constant inflow.
 Agent handles inbox zero for you. Everything gets triaged. Noise
 archived. Important stuff surfaced. Your inbox is always empty
 except for things that need your attention.
 You didn't achieve inbox zero. Your agent did.

 SUPPORT TICKETS BECOME OPTIONAL
 Right now: email support â†’ ticket system â†’ queue â†’ human responds.
 With agents: email support â†’ agent checks docs â†’ agent responds if
 confident â†’ creates ticket only if it needs human.
 Ticket volume drops 70%. Support team handles actual issues, not
 "how do I reset my password" questions.

 CALENDAR SCHEDULING DIES
 No more Calendly links. No more back-and-forth "how about Tuesday?"
 Person emails: "Can we meet next week?" Your agent checks calendar,
 proposes 3 times. Their agent checks their calendar, picks one. Both
 calendars updated. Done.
 Zero human touches for standard meeting scheduling.

 EMAIL BECOMES PROGRAMMABLE
 Right now: email is static. You read it, you respond. That's it.
 With agents: email is input to workflows. Receipt arrives â†’ extract
 data â†’ update spreadsheet. Invoice arrives â†’ verify amount â†’ pay
 automatically. Meeting request â†’ check availability â†’ schedule â†’
 prep briefing doc.
 Email triggers actions instead of requiring human processing.

 THE ARCHITECTURE
 How email agents actually work under the hood.
 // How inbox.dog actually works

interface InboxAgent {
 // User config
 config: {
 name: string;
 prompt: string; // Natural language instructions
 triggers: string[]; // When to activate
 integrations?: Integration[]; // MCP servers, APIs
 files?: File[]; // Knowledge base
 };
 
 // Runtime
 async processEmail(email: Email): Promise<Action[]> {
 // 1. Check if triggers match
 if (!this.shouldProcess(email)) return [];
 
 // 2. Build context
 const context = await this.buildContext({
 email,
 history: this.getEmailHistory(email.thread),
 knowledge: this.files,
 integrations: this.integrations
 });
 
 // 3. Ask AI what to do
 const decision = await ai.decide({
 prompt: this.config.prompt,
 context,
 availableActions: [
 "reply", "forward", "archive", 
 "delete", "label", "create_task"
 ]
 });
 
 // 4. Execute actions
 return this.execute(decision.actions);
 }
}

// It's a loop:
// - Email arrives
// - Check triggers
// - Build context (history, files, integrations) 
// - AI decides what to do based on your prompt
// - Execute actions
// - Log for learning

 THE EMAIL STATS EVERYONE IGNORES
 // Email statistics that matter

const emailWasteStats = {
 averageTimePerDay: "2.6 hours", // Checking and responding to email
 source: "McKinsey Global Institute",
 
 percentageValueless: "62%", // Of emails provide little to no value
 source: "Adobe Email Usage Study",
 
 interruptionCost: "23 minutes", // To refocus after email interruption 
 source: "UC Irvine Study",
 
 dailyEmailVolume: {
 sent: "347.3 billion", // Emails sent per day globally
 received: "Average person: 121 emails/day",
 source: "Radicati Group"
 },
 
 timeToProcess: {
 read: "11 seconds average",
 respond: "3-4 minutes average", 
 organize: "30 seconds average"
 }
};

// The math:
// - 121 emails/day
// - 62% are low-value (75 emails)
// - 11 seconds to read each
// - 30 seconds to archive/delete
// = 51 minutes/day on email triage alone

// Email agent handles the 75 low-value emails
// You handle the 46 that matter
// Save 51 minutes/day = 4.25 hours/week
 WHAT THIS MEANS You check email, take 11 seconds to read it, 30 seconds to decide what
 to do with it.
 That's 41 seconds per email. Times 75 low-value emails. 51 minutes per
 day of pure waste.
 Agent does that in milliseconds. Processes all 75 while you sleep.

 WHAT BREAKS
 Email clients - If agent handles most email, do you need
 Gmail UI? Maybe just an activity log and a way to override agent decisions.
 Support ticket systems - If agents answer 70% of support
 email, tickets become the exception not the rule.
 Scheduling tools - Calendly dies if agents can negotiate
 meeting times directly.
 Email marketing - If agents auto-archive newsletters people
 don't read, open rates plummet. Forces better targeting.
 Recruiting spam - Agent auto-responds to recruiters with
 your criteria. Only forwards matches. Recruiter spam gets handled in bulk.

 WHAT EMERGES
 Agent-to-agent protocols - Standard ways for agents to
 negotiate, exchange data, coordinate actions.
 Email as API - Email becomes structured message passing.
 Agents extract data, trigger workflows, execute actions.
 Programmable inboxes - Your inbox is a workflow engine.
 Emails are inputs. Actions are outputs.
 Activity dashboards - You don't "check email." You review
 what your agent did. Approve/override. Update instructions.
 Trust metrics - Agent success rate, override frequency,
 time saved. Data-driven tuning of agent behavior.

 WHY THIS MATTERS
 Email is broken. Not because the protocol is bad. Because humans spend
 13 hours per week on it and most of that time is wasted.
 We've tried to fix it with filters, rules, labels, folders. Doesn't
 scale. Too manual. Too fragile.
 AI agents are the first thing that can actually understand email
 content, context, and intent. They can read like a human, decide like a
 human, but execute instantly and never get tired.
 The capabilities just crossed the threshold where this works. High
 enough accuracy to trust, good enough context understanding, and ability
 to integrate with external tools.
 So yeah, an AI agent sitting in your inbox actually makes sense. The
 question isn't "should you use one?" It's "how long until everyone has
 one?"

 TRY IT
 We built inbox.dog to explore this. Plain-language agent config, MCP integration, file uploads,
 learning from history.
 Connect via MCP (works with ChatGPT, Claude, Cursor). Or use the web UI.
 Or API.
 Not trying to sell you. Just showing what's possible when you let AI
 handle email grunt work.

 Related ideas
 Trust Broker: Human-mediated agent communication
 Post-Form Web: Intent-based interfaces
 Agentic AI Architectures