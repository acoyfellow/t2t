<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸ¤–</text></svg>">

		<meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="generator" content="coey.dev" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link
      rel="preconnect"
      href="https://fonts.gstatic.com"
      crossorigin="anonymous"
    />
    <link class="deferred-stylesheet" rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Google+Sans:300,400,500,600,700&family=Google+Sans+Mono:300,400,500,600,700&amp;display=swap&amp;lang=en" as="style">

		
		<link href="./_app/immutable/assets/0.-k1r2YJt.css" rel="stylesheet">
		<link href="./_app/immutable/assets/CodeBlock.mf1IAhYo.css" rel="stylesheet"><!--12qhfyh--><meta name="description" content="Developer thoughts and code"/><!----><!--ojxrft--><meta name="description" content="Purge once, propagate everywhereâ€”no more stale edge."/> <meta name="keywords" content="cache, invalidation, edge, cloudflare, durable objects"/> <link rel="canonical" href="https://coey.dev/cache-sync"/> <meta name="author" content="Jordan Coeyman"/> <!--[!--><!--]--> <meta property="og:title" content="Cache Sync: Edge cache invalidation that actually scales"/> <meta property="og:description" content="Purge once, propagate everywhereâ€”no more stale edge."/> <meta property="og:type" content="article"/> <meta property="og:url" content="https://coey.dev/cache-sync"/> <meta property="og:image" content="https://api.coey.dev/?title=Cache%20Sync%3A%20Edge%20cache%20invalidation%20that%20actually%20scales&amp;description=Purge%20once%2C%20propagate%20everywhere%E2%80%94no%20more%20stale%20edge."/> <meta property="og:site_name" content="coey.dev"/> <meta name="twitter:card" content="summary_large_image"/> <meta name="twitter:title" content="Cache Sync: Edge cache invalidation that actually scales"/> <meta name="twitter:description" content="Purge once, propagate everywhereâ€”no more stale edge."/> <meta name="twitter:image" content="https://api.coey.dev/?title=Cache%20Sync%3A%20Edge%20cache%20invalidation%20that%20actually%20scales&amp;description=Purge%20once%2C%20propagate%20everywhere%E2%80%94no%20more%20stale%20edge."/> <meta name="twitter:site" content="@acoyfellow"/> <!--[--><meta property="article:published_time" content="2025-09-22"/> <meta property="article:modified_time" content="2025-09-22"/> <!--[--><meta property="article:section" content="technical"/><!--]--> <!--[--><meta property="article:tag" content="cloudflare,cache,edge"/><!--]--><!--]-->  <!----><script type="application/ld+json" nonce="%sveltekit.nonce%">{
  "@context": "https://schema.org",
  "@type": "Organization",
  "name": "Jordan Coeyman",
  "url": "https://coey.dev",
  "logo": {
    "@type": "ImageObject",
    "url": "https://coey.dev/jordan.jpg"
  },
  "sameAs": [
    "https://x.com/acoyfellow",
    "https://github.com/acoyfellow"
  ]
}</script><!----> <!--[!--><!--]--> <!--[--><!----><script type="application/ld+json" nonce="%sveltekit.nonce%">{
  "@context": "https://schema.org",
  "@type": "Article",
  "headline": "Cache Sync: Edge cache invalidation that actually scales",
  "description": "Purge once, propagate everywhereâ€”no more stale edge.",
  "image": "https://api.coey.dev/?title=Cache%20Sync%3A%20Edge%20cache%20invalidation%20that%20actually%20scales&description=Purge%20once%2C%20propagate%20everywhere%E2%80%94no%20more%20stale%20edge.",
  "wordCount": 0,
  "author": {
    "@type": "Organization",
    "name": "Jordan Coeyman"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Jordan Coeyman",
    "logo": {
      "@type": "ImageObject",
      "url": "https://coey.dev/jordan.jpg"
    }
  },
  "datePublished": "2025-09-22",
  "dateModified": "2025-09-22",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://coey.dev/cache-sync"
  }
}</script><!----><!--]--> <!--[!--><!--]--><!----><title>Cache Sync: Edge cache invalidation that actually scales</title>
	</head>
	<body data-sveltekit-preload-data="hover">
		<div style="display: contents"><!--[--><!--[--><!----><header class="flex items-center justify-between p-4 gap-4 flex-wrap" id="nav"><a href="/" class="px-4 py-2 md:px-8 md:py-4 md:text-2xl font-black hover:bg-white hover:text-black border-4 border-black hover:border-white bg-white text-black">coey.dev</a> <nav><div class="flex gap-0"><a href="/" class="px-4 py-2 md:px-8 md:py-4 md:text-2xl font-black hover:bg-white hover:text-black border-4 border-black bg-white text-black">POSTS</a> <a href="/about" class="px-4 py-2 md:px-8 md:py-4 md:text-2xl font-black hover:bg-black hover:text-white border-4 border-black border-l-0 bg-white text-black">ABOUT</a></div></nav></header> <div class="fixed inset-0 pointer-events-none -z-10" style="opacity: 0.7; mix-blend-mode: multiply; will-change: transform;"></div><!----> <main class="pt-20 relative"><!----><!--[--><!--]--> <main class="bg-white text-black"><div class="max-w-4xl mx-auto px-6 py-12"><header class="border-b-2 border-black pb-8 mb-12"><h1 class="text-4xl font-bold uppercase tracking-wider mb-4">CACHE SYNC</h1> <p class="text-xl font-mono">Edge cache invalidation that actually scales</p> <div class="mt-4 font-mono"><span class="bg-black text-white px-2 py-1">CACHING PATTERN</span> <span class="ml-4">2025.09.22</span></div></header> <section class="mb-12 border-l-2 border-black pl-6"><h2 class="text-2xl font-bold font-mono mb-4">THE EDGE CACHE PROBLEM</h2> <p class="text-lg leading-relaxed mb-4"><strong>Problem:</strong> Traditional cache invalidation doesn't scale. Purge
        one key, wait for global propagation, hope it worked.</p> <p class="leading-relaxed mb-4"><strong>Solution:</strong> Cache Sync uses Durable Objects as invalidation
        coordinators with tag/URL fan-out and backpressure handling.</p> <div class="bg-black text-white p-4 font-mono"><pre>Invalidate â†’ DO Coordinator â†’ Tag Fan-out â†’ Edge Purge
                â†“              â†“              â†“
            Backpressure    Rate Limiting   Global Sync</pre></div></section></div></main> <section class="p-8"><div class="max-w-4xl mx-auto space-y-10"><div><h2 class="text-2xl font-bold font-mono mb-4">PATTERN OVERVIEW</h2> <div class="grid grid-cols-1 md:grid-cols-2 gap-6"><div class="border-2 border-black p-6"><h3 class="text-xl font-bold font-mono mb-4">TRADITIONAL APPROACH</h3> <ul class="space-y-2 text-sm"><li>â€¢ Purge API calls to each edge location</li> <li>â€¢ No coordination between purges</li> <li>â€¢ Race conditions on concurrent updates</li> <li>â€¢ Expensive global propagation</li> <li>â€¢ No backpressure handling</li></ul></div> <div class="border-2 border-black p-6"><h3 class="text-xl font-bold font-mono mb-4">CACHE SYNC APPROACH</h3> <ul class="space-y-2 text-sm"><li>â€¢ Single DO coordinator per cache namespace</li> <li>â€¢ Tag-based invalidation with fan-out</li> <li>â€¢ Ordered invalidation with backpressure</li> <li>â€¢ Cost-effective edge propagation</li> <li>â€¢ Built-in rate limiting and retry logic</li></ul></div></div></div> <div><h2 class="text-2xl font-bold font-mono mb-4">KEY FEATURES</h2> <ul class="list-disc ml-6 space-y-1"><li><strong>Tag-based invalidation</strong> - Purge by tags, not individual
          keys</li> <li><strong>Ordered fan-out</strong> - Durable Object ensures consistent ordering</li> <li><strong>Backpressure handling</strong> - Prevents overwhelming edge locations</li> <li><strong>Rate limiting</strong> - Built-in protection against abuse</li> <li><strong>Retry logic</strong> - Automatic retry for failed invalidations</li> <li><strong>Cost optimization</strong> - Batch operations to reduce API calls</li> <li><strong>Global consistency</strong> - Eventually consistent across all
          edges</li></ul></div> <div><h2 class="text-2xl font-bold font-mono mb-4">COST COMPARISON</h2> <div class="bg-black text-white p-4 font-mono mb-4"><pre>Traditional: $800-$3500/month (1M requests)
Cache Sync:  $30-$100/month (1M requests)
Savings:     95%+ cost reduction</pre></div> <p class="text-sm text-gray-600">Based on 1M requests/month with traditional database vs Cache Sync
        pattern.</p></div> <div><h2 class="text-2xl font-bold font-mono mb-4">CACHE SYNC PATTERN</h2> <div class="border-2 border-black"><h3 class="px-4 py-2 border-b-2 border-black font-bold font-mono">Core Implementation</h3> <!--[!--><pre class="bg-black border-2 border-black p-4 overflow-x-auto text-white"><code>// src/lib/cache-sync.ts
export interface CacheInvalidationRequest {
  tags: string[];
  urls?: string[];
  namespace: string;
  priority: 'low' | 'normal' | 'high';
}

export interface CacheInvalidationResponse {
  id: string;
  status: 'queued' | 'processing' | 'completed' | 'failed';
  progress: number;
  totalEdges: number;
  completedEdges: number;
  errors?: string[];
}

export class CacheSyncCoordinator {
  private invalidationQueue: CacheInvalidationRequest[] = [];
  private activeInvalidations = new Map&lt;string, CacheInvalidationResponse>();
  private edgeLocations: string[] = [];
  private rateLimiter = new Map&lt;string, number>();

  constructor(private env: any) {
    this.initializeEdgeLocations();
  }

  async invalidate(request: CacheInvalidationRequest): Promise&lt;CacheInvalidationResponse> {
    const id = crypto.randomUUID();
    const response: CacheInvalidationResponse = {
      id,
      status: 'queued',
      progress: 0,
      totalEdges: this.edgeLocations.length,
      completedEdges: 0
    };

    this.activeInvalidations.set(id, response);
    this.invalidationQueue.push(request);

    // Process queue if not already processing
    if (this.invalidationQueue.length === 1) {
      this.processInvalidationQueue();
    }

    return response;
  }

  private async processInvalidationQueue(): Promise&lt;void> {
    while (this.invalidationQueue.length > 0) {
      const request = this.invalidationQueue.shift()!;
      const response = this.activeInvalidations.get(request.namespace);
      
      if (response) {
        response.status = 'processing';
        await this.executeInvalidation(request, response);
      }
    }
  }

  private async executeInvalidation(
    request: CacheInvalidationRequest, 
    response: CacheInvalidationResponse
  ): Promise&lt;void> {
    const batchSize = 10; // Process 10 edges at a time
    const batches = this.chunkArray(this.edgeLocations, batchSize);

    for (const batch of batches) {
      const promises = batch.map(edge => this.invalidateEdge(edge, request));
      const results = await Promise.allSettled(promises);

      // Update progress
      response.completedEdges += batch.length;
      response.progress = (response.completedEdges / response.totalEdges) * 100;

      // Handle errors
      const errors = results
        .filter((result): result is PromiseRejectedResult => result.status === 'rejected')
        .map(result => result.reason);

      if (errors.length > 0) {
        response.errors = [...(response.errors || []), ...errors];
      }

      // Rate limiting - wait between batches
      await new Promise(resolve => setTimeout(resolve, 100));
    }

    response.status = response.errors?.length ? 'failed' : 'completed';
  }

  private async invalidateEdge(edge: string, request: CacheInvalidationRequest): Promise&lt;void> {
    // Check rate limit
    const now = Date.now();
    const lastRequest = this.rateLimiter.get(edge) || 0;
    const timeSinceLastRequest = now - lastRequest;

    if (timeSinceLastRequest &lt; 100) { // 100ms rate limit
      await new Promise(resolve => setTimeout(resolve, 100 - timeSinceLastRequest));
    }

    this.rateLimiter.set(edge, Date.now());

    // Make invalidation request to edge
    const response = await fetch(`https://${edge}/purge`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${this.env.EDGE_API_KEY}`
      },
      body: JSON.stringify({
        tags: request.tags,
        urls: request.urls,
        namespace: request.namespace
      })
    });

    if (!response.ok) {
      throw new Error(`Failed to invalidate edge ${edge}: ${response.statusText}`);
    }
  }

  private chunkArray&lt;T>(array: T[], size: number): T[][] {
    const chunks: T[][] = [];
    for (let i = 0; i &lt; array.length; i += size) {
      chunks.push(array.slice(i, i + size));
    }
    return chunks;
  }

  private initializeEdgeLocations(): void {
    // In production, this would fetch from Cloudflare API
    this.edgeLocations = [
      'cache-1.cloudflare.com',
      'cache-2.cloudflare.com',
      'cache-3.cloudflare.com',
      // ... more edge locations
    ];
  }

  async getInvalidationStatus(id: string): Promise&lt;CacheInvalidationResponse | null> {
    return this.activeInvalidations.get(id) || null;
  }
}</code></pre><!--]--><!----></div></div> <div><h2 class="text-2xl font-bold font-mono mb-4">DURABLE OBJECT CACHE</h2> <div class="border-2 border-black"><h3 class="px-4 py-2 border-b-2 border-black font-bold font-mono">Per-Key Cache with In-Memory Access</h3> <!--[!--><pre class="bg-black border-2 border-black p-4 overflow-x-auto text-white"><code>// src/durable-objects/CacheDO.ts
import { DurableObject } from "cloudflare:workers";

export class CacheDO extends DurableObject {
  private cache = new Map&lt;string, any>();
  private writeBuffer: any[] = [];
  private lastSync = Date.now();

  async fetch(request: Request): Promise&lt;Response> {
    const url = new URL(request.url);
    const key = url.searchParams.get("key");

    if (!key) {
      return new Response("Missing key parameter", { status: 400 });
    }

    switch (request.method) {
      case "GET":
        return this.handleGet(key);
      case "POST":
        return this.handleSet(key, request);
      case "DELETE":
        return this.handleDelete(key);
      case "PUT":
        return this.handleInvalidate(request);
      default:
        return new Response("Method not allowed", { status: 405 });
    }
  }

  private async handleGet(key: string): Promise&lt;Response> {
    // Check in-memory cache first
    if (this.cache.has(key)) {
      const item = this.cache.get(key);
      
      // Check if expired
      if (item.expiresAt &amp;&amp; Date.now() > item.expiresAt) {
        this.cache.delete(key);
        return new Response("Not found", { status: 404 });
      }

      return new Response(JSON.stringify(item.data), {
        headers: { "Content-Type": "application/json" }
      });
    }

    // Cache miss - load from storage
    const stored = await this.ctx.storage.get(key);
    if (stored) {
      // Restore to in-memory cache
      this.cache.set(key, stored);
      return new Response(JSON.stringify(stored.data), {
        headers: { "Content-Type": "application/json" }
      });
    }

    return new Response("Not found", { status: 404 });
  }

  private async handleSet(key: string, request: Request): Promise&lt;Response> {
    const data = await request.json();
    const ttl = data.ttl || 3600; // Default 1 hour TTL
    
    const item = {
      data: data.value,
      createdAt: Date.now(),
      expiresAt: Date.now() + (ttl * 1000),
      tags: data.tags || []
    };

    // Update in-memory cache
    this.cache.set(key, item);
    
    // Add to write buffer
    this.writeBuffer.push({ key, item, operation: 'set' });
    
    // Schedule sync if buffer is full
    if (this.writeBuffer.length >= 10) {
      this.scheduleSync();
    }

    return new Response(JSON.stringify({ success: true }), {
      headers: { "Content-Type": "application/json" }
    });
  }

  private async handleDelete(key: string): Promise&lt;Response> {
    this.cache.delete(key);
    await this.ctx.storage.delete(key);
    
    this.writeBuffer.push({ key, operation: 'delete' });
    this.scheduleSync();

    return new Response(JSON.stringify({ success: true }), {
      headers: { "Content-Type": "application/json" }
    });
  }

  private async handleInvalidate(request: Request): Promise&lt;Response> {
    const { tags, urls } = await request.json();
    const keysToInvalidate: string[] = [];

    // Find keys by tags
    if (tags) {
      for (const [key, item] of this.cache.entries()) {
        if (item.tags &amp;&amp; item.tags.some((tag: string) => tags.includes(tag))) {
          keysToInvalidate.push(key);
        }
      }
    }

    // Find keys by URLs
    if (urls) {
      for (const url of urls) {
        const key = this.urlToKey(url);
        if (this.cache.has(key)) {
          keysToInvalidate.push(key);
        }
      }
    }

    // Invalidate found keys
    for (const key of keysToInvalidate) {
      this.cache.delete(key);
      await this.ctx.storage.delete(key);
    }

    return new Response(JSON.stringify({ 
      success: true, 
      invalidated: keysToInvalidate.length 
    }), {
      headers: { "Content-Type": "application/json" }
    });
  }

  private scheduleSync(): void {
    // Set alarm to sync in 60 seconds
    this.ctx.storage.setAlarm(Date.now() + 60000);
  }

  async alarm(): Promise&lt;void> {
    if (this.writeBuffer.length === 0) return;

    // Sync to main database
    const batch = this.writeBuffer.splice(0, 100); // Process up to 100 items
    
    for (const item of batch) {
      if (item.operation === 'set') {
        await this.ctx.storage.put(item.key, item.item);
      } else if (item.operation === 'delete') {
        await this.ctx.storage.delete(item.key);
      }
    }

    this.lastSync = Date.now();

    // Schedule next sync if there are more items
    if (this.writeBuffer.length > 0) {
      this.scheduleSync();
    }
  }

  private urlToKey(url: string): string {
    return `url:${btoa(url)}`;
  }
}</code></pre><!--]--><!----></div></div> <div><h2 class="text-2xl font-bold font-mono mb-4">WORKER IMPLEMENTATION</h2> <div class="border-2 border-black"><h3 class="px-4 py-2 border-b-2 border-black font-bold font-mono">Edge Routing and Cache Management</h3> <!--[!--><pre class="bg-black border-2 border-black p-4 overflow-x-auto text-white"><code>// src/worker.ts
import { CacheDO } from "./durable-objects/CacheDO";

export default {
  async fetch(request: Request, env: any): Promise&lt;Response> {
    const url = new URL(request.url);
    
    // Route to appropriate handler
    if (url.pathname.startsWith("/cache/")) {
      return handleCacheRequest(request, env);
    } else if (url.pathname.startsWith("/invalidate/")) {
      return handleInvalidationRequest(request, env);
    } else if (url.pathname.startsWith("/status/")) {
      return handleStatusRequest(request, env);
    }

    return new Response("Not found", { status: 404 });
  }
};

async function handleCacheRequest(request: Request, env: any): Promise&lt;Response> {
  const url = new URL(request.url);
  const key = url.searchParams.get("key");
  const namespace = url.searchParams.get("namespace") || "default";

  if (!key) {
    return new Response("Missing key parameter", { status: 400 });
  }

  // Get Durable Object for this namespace
  const id = env.CACHE_DO.idFromName(namespace);
  const obj = env.CACHE_DO.get(id);

  // Forward request to Durable Object
  return obj.fetch(request);
}

async function handleInvalidationRequest(request: Request, env: any): Promise&lt;Response> {
  const body = await request.json();
  const { tags, urls, namespace = "default", priority = "normal" } = body;

  if (!tags &amp;&amp; !urls) {
    return new Response("Missing tags or urls", { status: 400 });
  }

  // Get invalidation coordinator
  const id = env.INVALIDATION_COORDINATOR.idFromName(namespace);
  const obj = env.INVALIDATION_COORDINATOR.get(id);

  const response = await obj.fetch(new Request("/invalidate", {
    method: "PUT",
    body: JSON.stringify({ tags, urls })
  }));

  return response;
}

async function handleStatusRequest(request: Request, env: any): Promise&lt;Response> {
  const url = new URL(request.url);
  const id = url.searchParams.get("id");
  const namespace = url.searchParams.get("namespace") || "default";

  if (!id) {
    return new Response("Missing id parameter", { status: 400 });
  }

  // Get invalidation coordinator
  const coordinatorId = env.INVALIDATION_COORDINATOR.idFromName(namespace);
  const obj = env.INVALIDATION_COORDINATOR.get(coordinatorId);

  const response = await obj.fetch(new Request(`/status/${id}`));
  return response;
}</code></pre><!--]--><!----></div></div> <div><h2 class="text-2xl font-bold font-mono mb-4">FRONTEND COMPONENT</h2> <div class="border-2 border-black"><h3 class="px-4 py-2 border-b-2 border-black font-bold font-mono">Svelte Component with Offline Support</h3> <!--[!--><pre class="bg-black border-2 border-black p-4 overflow-x-auto text-white"><code>&lt;!-- src/components/CacheSync.svelte -->
&lt;script lang="ts">
  import { onMount, onDestroy } from 'svelte';
  
  let cacheData: any = null;
  let loading = false;
  let error: string | null = null;
  let syncStatus = 'online';
  let offlineQueue: any[] = [];

  onMount(() => {
    // Check network status
    syncStatus = navigator.onLine ? 'online' : 'offline';
    
    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);
    
    // Load cached data from localStorage
    loadFromLocalStorage();
    
    // Process offline queue if online
    if (syncStatus === 'online') {
      processOfflineQueue();
    }
  });

  onDestroy(() => {
    window.removeEventListener('online', handleOnline);
    window.removeEventListener('offline', handleOffline);
  });

  function handleOnline() {
    syncStatus = 'online';
    processOfflineQueue();
  }

  function handleOffline() {
    syncStatus = 'offline';
  }

  async function loadFromLocalStorage() {
    const cached = localStorage.getItem('cache-sync-data');
    if (cached) {
      cacheData = JSON.parse(cached);
    }
  }

  async function saveToLocalStorage(data: any) {
    localStorage.setItem('cache-sync-data', JSON.stringify(data));
  }

  async function fetchData(key: string) {
    loading = true;
    error = null;

    try {
      const response = await fetch(`/cache?key=${key}`);
      
      if (!response.ok) {
        throw new Error(`Failed to fetch: ${response.statusText}`);
      }

      const data = await response.json();
      cacheData = data;
      await saveToLocalStorage(data);
      
    } catch (err) {
      error = err instanceof Error ? err.message : 'Unknown error';
      
      // If offline, try to load from localStorage
      if (syncStatus === 'offline') {
        await loadFromLocalStorage();
      }
    } finally {
      loading = false;
    }
  }

  async function updateData(key: string, value: any, tags: string[] = []) {
    const update = { key, value, tags, timestamp: Date.now() };
    
    if (syncStatus === 'offline') {
      // Queue for later
      offlineQueue.push(update);
      await saveToLocalStorage({ ...cacheData, [key]: value });
      return;
    }

    try {
      const response = await fetch(`/cache?key=${key}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ value, tags })
      });

      if (!response.ok) {
        throw new Error(`Failed to update: ${response.statusText}`);
      }

      cacheData = { ...cacheData, [key]: value };
      await saveToLocalStorage(cacheData);
      
    } catch (err) {
      // Queue for retry
      offlineQueue.push(update);
      error = err instanceof Error ? err.message : 'Unknown error';
    }
  }

  async function invalidateCache(tags: string[]) {
    if (syncStatus === 'offline') {
      // Queue invalidation
      offlineQueue.push({ type: 'invalidate', tags, timestamp: Date.now() });
      return;
    }

    try {
      const response = await fetch('/invalidate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ tags })
      });

      if (!response.ok) {
        throw new Error(`Failed to invalidate: ${response.statusText}`);
      }

      // Clear local cache for invalidated tags
      if (cacheData) {
        const filtered = { ...cacheData };
        for (const [key, value] of Object.entries(filtered)) {
          if (value.tags &amp;&amp; value.tags.some((tag: string) => tags.includes(tag))) {
            delete filtered[key];
          }
        }
        cacheData = filtered;
        await saveToLocalStorage(cacheData);
      }
      
    } catch (err) {
      error = err instanceof Error ? err.message : 'Unknown error';
    }
  }

  async function processOfflineQueue() {
    if (offlineQueue.length === 0) return;

    const queue = [...offlineQueue];
    offlineQueue = [];

    for (const item of queue) {
      try {
        if (item.type === 'invalidate') {
          await invalidateCache(item.tags);
        } else {
          await updateData(item.key, item.value, item.tags);
        }
      } catch (err) {
        // Re-queue failed items
        offlineQueue.push(item);
      }
    }
  }
&lt;/script>

&lt;div class="cache-sync-container">
  &lt;!-- Status Indicator -->
  &lt;div class="status-indicator" class:offline={syncStatus === 'offline'}>
    &lt;span class="status-dot">&lt;/span>
    &lt;span class="status-text">
      {syncStatus === 'online' ? 'Online' : 'Offline'}
    &lt;/span>
    {#if offlineQueue.length > 0}
      &lt;span class="queue-count">{offlineQueue.length} queued&lt;/span>
    {/if}
  &lt;/div>

  &lt;!-- Error Display -->
  {#if error}
    &lt;div class="error-message">
      {error}
    &lt;/div>
  {/if}

  &lt;!-- Loading State -->
  {#if loading}
    &lt;div class="loading">
      Loading...
    &lt;/div>
  {/if}

  &lt;!-- Cache Data Display -->
  {#if cacheData}
    &lt;div class="cache-data">
      &lt;pre>{JSON.stringify(cacheData, null, 2)}&lt;/pre>
    &lt;/div>
  {/if}

  &lt;!-- Controls -->
  &lt;div class="controls">
    &lt;button on:click={() => fetchData('example-key')}>
      Fetch Data
    &lt;/button>
    &lt;button on:click={() => updateData('example-key', { value: 'updated' }, ['tag1'])}>
      Update Data
    &lt;/button>
    &lt;button on:click={() => invalidateCache(['tag1'])}>
      Invalidate Cache
    &lt;/button>
  &lt;/div>
&lt;/div>

&lt;style>
  .cache-sync-container {
    max-width: 800px;
    margin: 0 auto;
    padding: 20px;
  }

  .status-indicator {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 12px;
    border-radius: 4px;
    background: #e8f5e8;
    border: 1px solid #4caf50;
    margin-bottom: 16px;
  }

  .status-indicator.offline {
    background: #fff3cd;
    border-color: #ffc107;
  }

  .status-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: #4caf50;
  }

  .status-indicator.offline .status-dot {
    background: #ffc107;
  }

  .queue-count {
    background: #ff9800;
    color: white;
    padding: 2px 6px;
    border-radius: 12px;
    font-size: 12px;
  }

  .error-message {
    background: #ffebee;
    border: 1px solid #f44336;
    color: #c62828;
    padding: 12px;
    border-radius: 4px;
    margin-bottom: 16px;
  }

  .loading {
    text-align: center;
    padding: 20px;
    color: #666;
  }

  .cache-data {
    background: #f5f5f5;
    border: 1px solid #ddd;
    border-radius: 4px;
    padding: 16px;
    margin-bottom: 16px;
  }

  .cache-data pre {
    margin: 0;
    white-space: pre-wrap;
    word-break: break-word;
  }

  .controls {
    display: flex;
    gap: 12px;
    flex-wrap: wrap;
  }

  .controls button {
    padding: 8px 16px;
    border: 1px solid #ddd;
    border-radius: 4px;
    background: white;
    cursor: pointer;
    transition: background-color 0.2s;
  }

  .controls button:hover {
    background: #f5f5f5;
  }
&lt;/style></code></pre><!--]--><!----></div></div> <div><h2 class="text-2xl font-bold font-mono mb-4">WRANGLER CONFIG</h2> <div class="border-2 border-black"><h3 class="px-4 py-2 border-b-2 border-black font-bold font-mono">Cloudflare Workers Configuration</h3> <!--[!--><pre class="bg-black border-2 border-black p-4 overflow-x-auto text-white"><code># wrangler.toml
name = "cache-sync-pattern"
main = "src/worker.ts"
compatibility_date = "2024-03-01"
compatibility_flags = ["nodejs_compat"]

[durable_objects]
bindings = [
  { name = "CACHE_DO", class_name = "CacheDO" },
  { name = "INVALIDATION_COORDINATOR", class_name = "InvalidationCoordinatorDO" }
]

[[durable_objects.migrations]]
tag = "v1"
new_classes = ["CacheDO", "InvalidationCoordinatorDO"]

[vars]
MAIN_DB_API = "https://your-db-api.com"
EDGE_API_KEY = "your-edge-api-key"

# Development
[env.development]
vars = { MAIN_DB_API = "http://localhost:3000" }

# Production
[env.production]
vars = { MAIN_DB_API = "https://api.yourdomain.com" }</code></pre><!--]--><!----></div></div> <div><h2 class="text-2xl font-bold font-mono mb-4">ARCHITECTURE PATTERNS</h2> <div class="grid grid-cols-1 md:grid-cols-2 gap-6"><div class="border-2 border-black p-4"><h4 class="font-bold font-mono mb-3">READ PATH</h4> <ul class="text-sm space-y-1"><li>â€¢ Client â†’ Worker â†’ Dedicated User DO</li> <li>â€¢ Cache Miss â†’ Create New DO Instance</li> <li>â€¢ Return Stub with Background Load</li> <li>â€¢ Auto Refresh with Stale-While-Revalidate</li></ul></div> <div class="border-2 border-black p-4"><h4 class="font-bold font-mono mb-3">WRITE PATH</h4> <ul class="text-sm space-y-1"><li>â€¢ Client â†’ Dedicated User DO Instance</li> <li>â€¢ In-Memory State + Storage Update</li> <li>â€¢ Alarm â†’ Batch Sync to Main DB</li> <li>â€¢ Write Buffer Every 60s</li></ul></div> <div class="border-2 border-black p-4"><h4 class="font-bold font-mono mb-3">INVALIDATION FLOW</h4> <ul class="text-sm space-y-1"><li>â€¢ Tag-based Invalidation Request</li> <li>â€¢ DO Coordinator Fan-out</li> <li>â€¢ Rate Limited Edge Purges</li> <li>â€¢ Backpressure Handling</li></ul></div> <div class="border-2 border-black p-4"><h4 class="font-bold font-mono mb-3">OFFLINE SUPPORT</h4> <ul class="text-sm space-y-1"><li>â€¢ Network Detection</li> <li>â€¢ Local Storage Persistence</li> <li>â€¢ Auto Retry on Reconnect</li> <li>â€¢ Accessible Status Indicators</li></ul></div></div></div> <div><h2 class="text-2xl font-bold font-mono mb-4">IMPLEMENTATION PHASES</h2> <ol class="list-decimal ml-6 space-y-2"><li><strong>Shadow Mode:</strong> Run cache layer parallel to main API, compare
          results</li> <li><strong>Read-Only Canary:</strong> Route 5% of read traffic through cache</li> <li><strong>Write Queueing:</strong> Enable write buffering for canary users</li> <li><strong>Full Cutover:</strong> Gradually increase traffic over 1-2 weeks</li></ol></div> <div><h2 class="text-2xl font-bold font-mono mb-4">PERFORMANCE CHARACTERISTICS</h2> <ul class="list-disc ml-6 space-y-1"><li><strong>Cache hit latency:</strong> &lt;5ms for cached responses</li> <li><strong>Invalidation propagation:</strong> &lt;1s global consistency</li> <li><strong>Write buffering:</strong> 60s batch intervals</li> <li><strong>Backpressure handling:</strong> Automatic rate limiting</li> <li><strong>Cost reduction:</strong> 95%+ vs traditional approaches</li> <li><strong>Global distribution:</strong> 200+ edge locations</li></ul></div> <div><h2 class="text-2xl font-bold font-mono mb-4">USE CASES</h2> <ul class="list-disc ml-6 space-y-1"><li>High-traffic e-commerce with frequent inventory updates</li> <li>Content management systems with global content distribution</li> <li>API gateways requiring consistent cache invalidation</li> <li>Real-time applications with frequent data updates</li> <li>Multi-tenant SaaS platforms with isolated cache namespaces</li> <li>Social media platforms with viral content propagation</li> <li>Gaming platforms with leaderboard and state updates</li></ul></div> <div><h2 class="text-2xl font-bold font-mono mb-4">FUTURE ENHANCEMENTS</h2> <ul class="list-disc ml-6 space-y-1"><li><strong>Data Compression:</strong> Store more data in Durable Object state</li> <li><strong>TTL Expiration:</strong> Automatically expire stale data</li> <li><strong>Rate Limiting:</strong> Prevent API abuse with smart throttling</li> <li><strong>Auth Integration:</strong> Add request validation and security</li> <li><strong>Metrics Dashboard:</strong> Track cache performance and costs</li> <li><strong>Predictive Invalidation:</strong> ML-based cache warming</li></ul></div> <div class="border-t-2 border-black pt-6"><h3 class="text-xl font-bold font-mono mb-2">Related patterns</h3> <ul class="list-disc ml-6"><li><a class="underline" href="/userdo">UserDO: Per-user Durable Objects</a></li> <li><a class="underline" href="/tenancy-isolation">Tenancy Isolation: Multi-tenant rate limiting</a></li> <li><a class="underline" href="/fleet-pattern">Fleet Pattern: Hierarchical Durable Objects</a></li> <li><a class="underline" href="/workflow-live">Workflow Live: Real-time workflow monitoring</a></li></ul></div></div></section><!----><!----></main><!----><!--]--> <!--[!--><!--]--><!--]-->
			
			<script>
				{
					__sveltekit_seuxg2 = {
						base: new URL(".", location).pathname.slice(0, -1)
					};

					const element = document.currentScript.parentElement;

					Promise.all([
						import("./_app/immutable/entry/start.B6XN_71n.js"),
						import("./_app/immutable/entry/app.BC487iTC.js")
					]).then(([kit, app]) => {
						kit.start(app, element, {
							node_ids: [0, 9],
							data: [{type:"data",data:{user:null,session:null},uses:{}},null],
							form: null,
							error: null
						});
					});
				}
			</script>
		</div>
	</body>
</html>
